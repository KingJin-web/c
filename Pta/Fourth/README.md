# 算法设计与分析第四次作业：回溯


## [7-1 青蛙过桥 (25 分)](a.cpp)

一座长度为n的桥，起点的一端坐标为0，且在整数坐标i处有a[i]个石头【0<=a[i]<=4】， 一只青蛙从坐标0处开始起跳，一步可以跳的距离为1或2或3【即每一步都会落在整数点处】， 青蛙落在i处会踩着该点的所有石头，求青蛙跳出这座桥最少踩多少个石头？并且输出依次跳 过的坐标点路线，如果存在多种路线，输出字典序最小的那一条。

### 输入格式:

第一行整数n(<150000)，接着下一行会有n+1个由空格隔开的整数,即桥上各个坐标处石头数量。

### 输出格式:

第一行为踩着最少石头个数，第二行为依次跳过的坐标点【字典序最小的】。

### 输入样例:

在这里给出两组输入。例如：

```in
10
1 2 1 3 0 3 1 2 1 1 2
```

```in
100
1 2 0 4 0 1 3 4 2 2 1 3 1 4 0 3 0 1 2 3 3 2 2 0 1 0 0 0 0 1 2 1 3 4 0 3 4 4 1 0
4 1 3 1 1 2 3 4 4 4 0 2 0 1 1 1 3 1 3 2 1 2 4 1 2 1 4 1 0 0 1 2 3 0 2 4 4 0 0 4
2 0 0 2 1 3 3 3 0 0 2 0 0 1 2 4 2 2 2 4 0
```

### 输出样例:

在这里给出对应的输出。例如：

```out
4
0 2 4 6 8
```

```out
36
0 2 4 5 8 10 12 14 16 17 20 23 25 26 27 28 31 34 35 38 39 41 44 47 50 52 54 57 60 63 65 68 69 70 73 74 77 78 81 82 85 88 89 91 92 94 97 100
```



## [7-2 找零钱*** (20 分)](b.cpp)

收银员现有 **n** 张面值分别为 **v****1********,****v****2********,****.****.****.****,****v****n****** 的纸币。若找零金额为 **m**，则一共有多少种找零方法？

注：**0****<****n****≤****1****0****0****0**，**0****<****v****1********,****v****2********,****.****.****.****,****v****n********≤****1****0****0****0****0**，**0****<****m****≤****1****0****0****0****0**

#### 输入格式

> **n** **v****1********,****v****2********,****.****.****.****,****v****n****** **m**

#### 输出格式

> 若有解，则输出全部找零方案，每输出一种 若无解，则输出“None”

#### 输入样例1

```in
6
3 1 4 3 2 7
9
```

#### 输出样例1

```out
3 1 3 2
3 4 2
4 3 2
2 7
```

#### 输入样例2

```in
5
5 3 4 6 7
2
```

#### 输出样例2

```out
None
```


## [7-3 自然数拆分问题 (60 分)](c.cpp)

一个整数N(N > 1)可以拆分成若干个大于等于1的自然数之和，请你输出所有不重复的拆分方式。

所谓拆分方式的重复性判定如下：给定**N****=****a****1********+****a****2********+****.****.****.****a****m****1****** 和 **N****=****b****1********+****b****2********+****.****.****.****b****m****2****** 表示整数N的两种拆分方式。对于**∀****a****i********,****b****j********≥****1**，令集合**A****=****{****a****i********∣****1****≤****i****≤****m****1********}****,****B****=****{****b****j********∣****1****≤****j****≤****m****2********}**。若满足集合**A****=****B**，则称这两种拆分方式是重复的。

例如 6 = 3 + 2 和 6 = 2 + 3, 就是重复的拆分方式。

### 输入格式:

一个正整数N（**1****≤****N****≤****5****2**）。

**注意：本题N的上限52，是经过PTA平台服务器测试后得到的上限，能够保证较好的搜索策略在PTA提交，在1s内求解。本地PC机上，即使较好方法运行时间也可能大于1s，如果觉得方法没问题，可以先提交试试。**

### 输出格式:

按照拆分方案的字典序由小大到大，输出所有方案，请参考输出样例

### 输入样例:

在这里给出一组输入。例如：

```in
6
```

### 输出样例:

在这里给出相应的输出。例如：

```out
6=1+1+1+1+1+1
6=1+1+1+1+2
6=1+1+1+3
6=1+1+2+2
6=1+1+4
6=1+2+3
6=1+5
6=2+2+2
6=2+4
6=3+3
6=6
```



## [7-4 数独游戏 (10 分)](d.cpp)

![微信截图_20200510171112.png](https://images.ptausercontent.com/a76349a7-0d04-43b1-be20-ec89e44db1ac.png)

### 输入格式:

**The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”.**

*注意： 本题输入数据量较大，cin, getline可能会超时，建议使用scanf。*

### 输出格式:

**For each test case, print a line representing the completed Sudoku puzzle.**

### 输入样例:

在这里给出一组输入。例如：

```in
.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.
......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.
end
```

### 输出样例:

在这里给出相应的输出。例如：

```out
527389416819426735436751829375692184194538267268174593643217958951843672782965341
416837529982465371735129468571298643293746185864351297647913852359682714128574936
```



## [7-5 种苹果 (30 分)](e.cpp)

最近流行种苹果的游戏，玩家种下一颗苹果树，初始成长值为0，每次浇水都会增加成长值，当成长值大于等于V时，就可以收获成熟的苹果了。玩家拥有五种颜色（红色、黄色、蓝色、绿色、紫色）的水壶若干个，每浇水一次就消耗一个水壶，不同颜色的水壶水量不一定一样，因此用不同颜色的水壶浇水苹果树获得的成长值也可能不一样。苹果成熟后剩余水壶中的水量仍然可以继续在下一局游戏中继续使用，因此，玩家想用最少的水量让苹果成熟，最大程度节约水量。请你帮他计算下苹果成熟的最少浇水量。

### 输入格式:

输入第一行为一个整数T（1<=T<=100），代表测试数据的组数，每组数据的第一行为一个整数V(0<=V<=10^12)，代表苹果成熟应达到的成长值，随后5行，每行包括三个整数N,G,W（0<=N<=1000,0<=W,G<=10^9），分别代表其中一种颜色水壶的个数，浇水后对应的成长值，水量，中间用空格分割，并且所有颜色水壶的总个数不超过1000。

### 输出格式:

每组数据都对应一行输出。如果苹果能够成熟，该行输出两个整数，分别代表苹果成熟时的最低浇水量和所获得的成长值。如果所有水壶的水量都浇上，苹果也成熟不了，则输出”Impossible!”。

### 输入样例:

```in
3
100
20 5 5
16 10 4
3 20 10
15 2 2
5 8 6
60
2 3 2
3 5 6
1 3 5
2 6 1
3 4 2
50
2 20 10
3 10 20
2 5 6
20 4 10
12 6 5

```

### 输出样例:

```out
40 100
Impossible!
30 52
```


## [7-6 八皇后问题 (20 分)](f.cpp)

会下国际象棋的人都很清楚：皇后可以在横、竖、斜线上不限步数地吃掉其他棋子。如何将8个皇后放在棋盘上（有8 * 8个方格），使它们谁也不能被吃掉！这就是著名的八皇后问题。 对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。 给出一个数b，要求输出第b个串。串的比较是这样的：皇后串x置于皇后串y之前，当且仅当将x视为整数时比y小。。

### 输入格式:

第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数b(1 <= b <= 92)。

### 输出格式:

输出有n行，每行输出对应一个输入。输出应是一个正整数，是对应于b的皇后串。

### 输入样例:

```in
2
1
92
```

### 输出样例:

```out
15863724
84136275
```



## [7-7 幂集-所有的子集 (20 分)](g.cpp)

所谓幂集（Power Set）， 就是原集合中所有的子集（包括全集和空集）构成的集族。

输入一个整数n（0<=n<=10） 输出由整数1~n构成的集合{1,2,3,...,n}的幂集。

### 输入格式:

整数n（0<=n<=10）

### 输出格式:

{1,2,3,...,n}的幂集，每行一个子集，子集不可重复，子集之间顺序以及子集元素之间顺序均不作要求。 子集输出格式：{x,x,x,..,x}(x表示子集中的元素)

### 输入样例1:

```in
3
```

### 输出样例1:

```out
{}
{1}
{2}
{3}
{1,2}
{1,3}
{2,3}
{1,2,3}
```

### 输入样例2:

```in
0
```

### 输出样例2:

```out
{}
```

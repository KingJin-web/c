# 算法设计与分析第四次作业：回溯


## [7-1 青蛙过桥 (25 分)](a.cpp)

一座长度为n的桥，起点的一端坐标为0，且在整数坐标i处有a[i]个石头【0<=a[i]<=4】， 一只青蛙从坐标0处开始起跳，一步可以跳的距离为1或2或3【即每一步都会落在整数点处】， 青蛙落在i处会踩着该点的所有石头，求青蛙跳出这座桥最少踩多少个石头？并且输出依次跳 过的坐标点路线，如果存在多种路线，输出字典序最小的那一条。

### 输入格式:

第一行整数n(<150000)，接着下一行会有n+1个由空格隔开的整数,即桥上各个坐标处石头数量。

### 输出格式:

第一行为踩着最少石头个数，第二行为依次跳过的坐标点【字典序最小的】。

### 输入样例:

在这里给出两组输入。例如：

```in
10
1 2 1 3 0 3 1 2 1 1 2
```

```in
100
1 2 0 4 0 1 3 4 2 2 1 3 1 4 0 3 0 1 2 3 3 2 2 0 1 0 0 0 0 1 2 1 3 4 0 3 4 4 1 0
4 1 3 1 1 2 3 4 4 4 0 2 0 1 1 1 3 1 3 2 1 2 4 1 2 1 4 1 0 0 1 2 3 0 2 4 4 0 0 4
2 0 0 2 1 3 3 3 0 0 2 0 0 1 2 4 2 2 2 4 0
```

### 输出样例:

在这里给出对应的输出。例如：

```out
4
0 2 4 6 8
```

```out
36
0 2 4 5 8 10 12 14 16 17 20 23 25 26 27 28 31 34 35 38 39 41 44 47 50 52 54 57 60 63 65 68 69 70 73 74 77 78 81 82 85 88 89 91 92 94 97 100
```



## [7-2 找零钱*** (20 分)](b.cpp)

收银员现有 **n** 张面值分别为 **v****1********,****v****2********,****.****.****.****,****v****n****** 的纸币。若找零金额为 **m**，则一共有多少种找零方法？

注：**0****<****n****≤****1****0****0****0**，**0****<****v****1********,****v****2********,****.****.****.****,****v****n********≤****1****0****0****0****0**，**0****<****m****≤****1****0****0****0****0**

#### 输入格式

> **n** **v****1********,****v****2********,****.****.****.****,****v****n****** **m**

#### 输出格式

> 若有解，则输出全部找零方案，每输出一种 若无解，则输出“None”

#### 输入样例1

```in
6
3 1 4 3 2 7
9
```

#### 输出样例1

```out
3 1 3 2
3 4 2
4 3 2
2 7
```

#### 输入样例2

```in
5
5 3 4 6 7
2
```

#### 输出样例2

```out
None
```


## [7-3 自然数拆分问题 (60 分)](c.cpp)

一个整数N(N > 1)可以拆分成若干个大于等于1的自然数之和，请你输出所有不重复的拆分方式。

所谓拆分方式的重复性判定如下：给定**N****=****a****1********+****a****2********+****.****.****.****a****m****1****** 和 **N****=****b****1********+****b****2********+****.****.****.****b****m****2****** 表示整数N的两种拆分方式。对于**∀****a****i********,****b****j********≥****1**，令集合**A****=****{****a****i********∣****1****≤****i****≤****m****1********}****,****B****=****{****b****j********∣****1****≤****j****≤****m****2********}**。若满足集合**A****=****B**，则称这两种拆分方式是重复的。

例如 6 = 3 + 2 和 6 = 2 + 3, 就是重复的拆分方式。

### 输入格式:

一个正整数N（**1****≤****N****≤****5****2**）。

**注意：本题N的上限52，是经过PTA平台服务器测试后得到的上限，能够保证较好的搜索策略在PTA提交，在1s内求解。本地PC机上，即使较好方法运行时间也可能大于1s，如果觉得方法没问题，可以先提交试试。**

### 输出格式:

按照拆分方案的字典序由小大到大，输出所有方案，请参考输出样例

### 输入样例:

在这里给出一组输入。例如：

```in
6
```

### 输出样例:

在这里给出相应的输出。例如：

```out
6=1+1+1+1+1+1
6=1+1+1+1+2
6=1+1+1+3
6=1+1+2+2
6=1+1+4
6=1+2+3
6=1+5
6=2+2+2
6=2+4
6=3+3
6=6
```



## [7-4 数独游戏 (10 分)](d.cpp)

![微信截图_20200510171112.png](https://images.ptausercontent.com/a76349a7-0d04-43b1-be20-ec89e44db1ac.png)

### 输入格式:

**The input test file will contain multiple cases. Each test case consists of a single line containing 81 characters, which represent the 81 squares of the Sudoku grid, given one row at a time. Each character is either a digit (from 1 to 9) or a period (used to indicate an unfilled square). You may assume that each puzzle in the input will have exactly one solution. The end-of-file is denoted by a single line containing the word “end”.**

*注意： 本题输入数据量较大，cin, getline可能会超时，建议使用scanf。*

### 输出格式:

**For each test case, print a line representing the completed Sudoku puzzle.**

### 输入样例:

在这里给出一组输入。例如：

```in
.2738..1..1...6735.......293.5692.8...........6.1745.364.......9518...7..8..6534.
......52..8.4......3...9...5.1...6..2..7........3.....6...1..........7.4.......3.
end
```

### 输出样例:

在这里给出相应的输出。例如：

```out
527389416819426735436751829375692184194538267268174593643217958951843672782965341
416837529982465371735129468571298643293746185864351297647913852359682714128574936
```

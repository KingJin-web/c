# 一、选择题(共10个小题，每小题2分，共20分)

1、  用计算机解决问题的步骤一般为：（`D`）

①编写程序 ②设计算法 ③分析问题 ④调试程序

`A、①②③④`    `B、③④①②`

`C、②③①④ `   **` D、③②①④`**

2、  以下描述不正确的是（C）

`A、 组成算法的每条指令是没有歧义的`

`B、 算法中每条指令的执行时间是有限的`

**`C、 在算法的循环结构中，指令的执行次数可以无限`**

`D、 组成算法的每条指令是清晰的`

3、  将一个难以直接解决的大问题，分解成一些规模较小的相同问题，以便各个击破。这属于_____的解决方法。（B）

`A、 动态规划`   **`B、分治法`**  ` C、贪心算法`   `D、分支界限法 `

4、  以下对于动态规划描述不正确的是（D）

`A、 动态规划法与分治法类似，其基本思想也是将待求解问题分解成若干子问题`
`B、 适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的 `
`C、 具体的动态规划算法多种多样，但是他们具有相同的填表格式`
**`D、 动态规划求解问题时和分治法一样，对子问题重复计算多次`**

5、  有3个矩阵A维数是{10*100}，B维数是{100*5}，C维数是{5*50}，若按（（AB）C）计算，3个矩阵连乘积需要的乘法次数是（A）

**` A、7500`**   `B、75000   C、750 D、750000`

6、以下增长最快的是（D）

` A、log2n  B、nlog2n  C、n2`  **` D、2n` **

7、  以下描述正确的是（B）

A、 递归算法只能直接调用自身

B、 递归函数是由函数自身给出定义的

C、 每个递归函数不一定都要有非递归定义的初始值

D、 以上都不正确

8、  以下哪种算法是以深度优先策略进行搜索的（A）

A、回溯法  B、分支界限法  C、贪心算法 D、随机化算法 9、动态规划算法适用于解最优化问题，以下哪个不是动态规划法解决问题的步骤（C）

A、 找出最优解的性质，并刻画其结构特征

B、 递归地定义最优值

C、 以自顶向下的方式计算出最优值

D、 根据计算最优值时得到的信息，构造最优解

10、算法分析中，记号O表示（B）

A.渐进下界

B.渐进上界

C.非紧上界

D.紧渐进界

11、下面关于算法的错误说法是（B）

A、 算法必须有输出 B、算法必须在计算机上用某种语言实现

```
C、算法不一定有输入  D、算法必须在有限步执行后能结束
```


12、以下哪种算法是以广度优先策略进行搜索的（B）

A、 回溯法 B、分支界限法  C、贪心算法 D、随机化算法

13、以下增长最慢的是（A）

A、 log2n  B、nlog2n  C、n2    D、2n

14、二分搜索算法是利用____实现的算法。（A）

```
A、分治策略  B、动态规划法  C、贪心法  D、回溯法
```


15、0-1背包问题的回溯算法所需的计算时间为（A）

A、O（n2n） B、O（nlogn） C、O（2n） D、O（n）

16、下列不是动态规划算法基本步骤的是（C）。

A、   找出最优解的性质  B、构造最优解  C、算出最优解  D、定义最优解

17、设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ，则以下描述不正确的是（D）

`A、   若xm=yn，则zk=xm=yn，且Zk-1是Xm-1和Yn-1的最长公共子序列`

`B、   若xm≠yn且zk≠xm，则Z是xm-1和Y的最长公共子序列`

`C、   若xm≠yn且zk≠yn，则Z是X和yn-1的最长公共子序列`

**`D、   若xm=yn，则zk≠xm≠yn，且Zk-1是Xm-1和Yn-1的最长公共子序列`**

18、下列算法中通常以深度优先方式系统搜索问题解的是（D）

` A、备忘录法` `B、动态规划法`  `C、贪心法 ` **`D、回溯法`**

# 二、填空题(共10空，每空2分，共20分)

1、 递归与分治算法应满足条件：___最优子结构性质___与___独立子问题___

2、 按照渐近阶从低到高的顺序排列下列表达式： 2*n*,*n*,,4*n*3,*n*log*n*，结果为

___n,nlogn,4n3,2n___。

3、 回溯法中的解空间树结构通常有两种，分别是___子集树___、___排列树___。

4、 算法满足的性质：___输入___、___输出___、___确定性___、有限性。

5、 一个直接或间接地调用自身的算法称为___递归____，它有两个条件，一个是要直接或间接地调用自身，另一个是必须有_____边界条件_______。

6、 以广度优先或以最小耗费方式搜索问题解的算法称为______分支限界法______。

7、 ___最优子结构性质___和___重叠子问题___是采用动态规划算法的两个基本要素。

8、 按照渐近阶从低到高的顺序排列下列表达式： n2,logn,3n,45n,6,3n3/2,n! ，结

果为__6，logn，45n，3n3/2，n2，3n ，n!___。

9、 多项式*A*(*n*) *a**m**n**m* L*a*1*n**a*0 的上界为___O（nm）___。

10、使用回溯法进行状态空间树裁剪分支时一般有两个标准：约束条件和目标函数的界，N皇后问题和0/1背包问题正好是两种不同的类型，其中同时使用约束条件和目标函数的界进行裁剪的是___0/1背包问题___，只使用约束条件进行裁剪的是___N皇后问题___。

11、f(n)=n^3+10*n+1000000的时间复杂度是___O（n3）__。 12、算法的复杂性有 ___时间___复杂性和空间复杂性之分。

13、程序是 ___算法___用某种程序设计语言的具体实现。

14、算法的“确定性”指的是组成算法的每条 ___指令___是清晰的，无歧义的。

15、从分治法的一般设计模式可以看出，用它设计出的程序一般是__递归算法__。

16、分治法的基本思想是首先将待求解问题分解成若干____子问题____。

17、回溯法搜索解空间树时，常用的两种剪枝函数为约束函数和____限界函数____。

18、解决0/1背包问题可以使用动态规划、回溯法，其中不需要排序的是 ___动态规划___，需要排序的是 ___回溯法___。

19、10000*n^2+10*n+1的时间复杂度是___O（n2）___。

# 三、简答题(2个小题，每小题5分，共10分）

1、 简述利用回溯法解决问题的一般步骤。

（1）   定义一个解空间，它包含问题的解；

（2）   利用适于搜索的方法组织解空间；

（3）   利用深度优先搜索解空间；

（4）   利用剪枝函数避免移动到不可能产生解的子空间。

2、 动态规划算法的基本思想是什么？请简述动态规划算法主要设计步骤。

（1）   基本思想：

将待求解问题分解成若干个相互关联的与原问题类似的子问题，求解这些子问

题，并保存子问题的答案，避免重复计算，然后从这些子问题的解得到原问题的解。

（2）   设计步骤：

①找出最优解的性质，并刻化其结构特征；

②递归地定义最优值；

③以自底向上的方式计算出最优值；

④根据计算最优值时得到的信息，构造最优解。

3、 简述分治法的基本步骤。

（1）   分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

（2）   解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；

（3）   合并：将各个子问题的解合并为原问题的解。

4、 比较贪心算法与动态规划算法的异同，它们都有哪些优势和劣势？

（1）   共同点：都是一种递归算法，均有局部最优解来推导全局最优解；

（2）   区别：贪心算法中，做出的每步贪心决策都无法改变，每一步的最优解一定包含上一步的最优解，而上一步之前的最优解则不做保留；动态规划算法中，全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解；

（3）   优势劣势：动态规划算法利用子问题重叠性质，对每一个子问题只计算一次，将其解保存在一个表格中。不同的子问题个数随着输入问题的规模呈多项式增长，因此，动态规划算法通常只需要多项式时间，从而获得较高的解题效率。但它需要计算之前所有情况花费，更加耗费空间。贪心算法所作的选择依赖于以往所作过的选择,但决不依赖于将来的选择,这使得算法在编码和执行过程中都有一定的速度优势。贪心算法是只是找局部最优解，不一定是全局最优解。

5、简述分支限界法和回溯法的异同

（1）   求解目标不同：回溯法的求解目标是找出解空间树中满足约束条件的所有可行解；而分枝限界法的求解目标则是找出满足约束条件的一个可行解，或某种意义下的最优解。

（2）   搜索方式不同：回溯法以深度优先的方式搜索解空间树，而分枝限界法则以广度优先的方式搜索解空间树。

（3）   对当前扩展结点的扩展方式不同：回溯法中的每个活结点可能多次成为当前扩展结点，纵深方向扩展其一个儿子，然后再回溯后扩展其他儿子；而分枝限界法中每一个活结点只有一次机会成为扩展结点，一次产生所有孩子结点，自身成为死结点，之后无需再返回该结点处。

6、简述分治法所能解决的问题一般具有的特征。

（1）   可缩性。问题的规模缩小到一定的程度就可以容易地解决；

（2）   最有子结构性。问题可以分解为若干个规模较小的相同问题；

（3）   可合性。利用该问题分解出的子问题的解可以合并为该问题的解；

（4）   独立性。该问题所分解出的各个子问题是相互独立的，即子问 题之间不包含

公共的子子问题。

# 四、应用题（1个小题，共10分）

1.使用回溯法解0/1背包问题：n=3，C=9，V={6,10,3}，W={3,4,4},其解空间有长度为3的0-1向量组成，要求用一棵完全二叉树表示其解空间（从根出发，左1右0），并画出其解空间树，计算其最优值及最优解。

2.用动态规划策略求解最长公共子序列问题：

（1） 给出计算最优值的递归方程。（4分）

（2） 给定两个序列X={B,A,B,A}，Y={A,B,C,B}，请采用动态规划策略求出其最长公共子序列，要求给出过程（画出求解表格）。（4分）

3.某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高 于前一发的高度。 某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。现输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹及拦截的各导弹高度是多少，并写出推导过程。输入：389 154 155

302 299 170 158 65 320 296 111 222 555 68 189

# 五、算法实现题(4个小题，每小题10分，共40分）

**注：在对算法实现时，编程语言不限，各算法需要用子函数实现，并在main函数中测试**。

### 1. 超级楼梯问题：

有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级h或三级，要走上第M级，共有多少种走法？要求时间复杂度为O(n)，空间复杂度为O(1)。

```c++
/*
1. 楼梯问题
1级：1种
2级：2种
3级：4种
4级：1+2+4=7种 （前3个和）
5级：2+4+7=13种 （前3个和）
6级：4+7+13=24种 （前3个和）
7级：7+13+24=44种 （前3个和）
8级：13+24+44=81种（前3个和）
*/
int T1(int m)
{
    int F[5] = {0, 1, 2, 4, 0};

    if (m > 0 && m < 4)
        return F[m];

    for (int i = 4; i <= m; i++)
    {
        F[4] = F[1] + F[2] + F[3];
        F[1] = F[2];
        F[2] = F[3];
        F[3] = F[4];
    }
    return F[4];
}

```

### 2、请用递归算法判断一个整数数组是否是对称的，比如数组为就是对称的。要求递归函数返回bool类型。

```c++
bool isDuciCheng(int a[], int left, int right)
{
    if (left >= right)
      return true;

    bool b = a[left] == a[right] && isDuciCheng(a, left + 1, right - 1);
    return b;
}
```

### 3、最大子段和问题：给出一个序列，其子段为该序列的一个连续的区间。

例如：(1 -1 2 23 -3 4 -4) ，(2 2 3 -34)为他的一个子段。给出一个序列，求出数字求和最大的一个子段。例如上面的序列， (22 3 -3 4)就是一个最大的子段，数字的总和为8。

### 4、将正整数n表示成一系列正整数之和：n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。正整数n的这种表示称为正整数n的划分。输出正整数n的不同划分个数及具体的划分形式。

例如正整数6有如下11种不同的划分：

> 6；
> 5+1；
> 4+2，4+1+1；
> 3+3，3+2+1，3+1+1+1；
> 2+2+2，2+2+1+1，2+1+1+1+1；
> 1+1+1+1+1+1

```c++
#include <iostream>
using namespace std;

int cnt = 0, tot;
int a[100];
void fun(int n, int sum)
{
    if (sum == tot) //注意这里的打印技巧

    {
        for (int i = 0; i < cnt - 1; ++i)
            printf("%d+", a[i]);
        if (tot - a[0] == cnt - 1)
            printf("%d\n", a[cnt - 1]);
        else
            printf("%d,", a[cnt - 1]);
        return;
    }
    for (int i = n; i > 0; --i)
    {
        if (sum + i <= tot)
        {
            a[cnt++] = i;
            fun(i, sum + i); //注意这里不是fun (n - i, sum+i),因为每次的划分结果都是从大到小排序的
                             //所以每次枚举的最大数不能大于上一次的值;
            cnt--;           //  记得这里要回溯
        }
    }
}
int main()
{

    //正整数n
    tot = 6;
    fun(tot, 0);
}
```



### 5.请用分支限界法实现：

八皇后问题：在8×8的国际象棋盘上，放置八个皇后，使任何一个皇后都不能吃掉另一个

国际象棋规则中，皇后可以吃到任何一个与他在同一行、同一列或者同一斜线上的敌方棋子，所以八皇后问题的所有解满足：

8个皇后都不在同一行、同一列，或者同一斜线上；或者任意行、列或者斜线上
有且仅有一个皇后。

## 6、给定一个高度为 n 的“数字三角形”，其中第 i 行（1\<=i\<=n）有 i个数。

（例子如下图所示）

1

2 3

4 5 6

7 8 9 10

初始时，你站在“数字三角形”的顶部，即第一行的唯一一个数上。每次移动，你可以选择移动到当前位置正下方或者当前位置右下方的位置上。即如果你在
(i,j)（表示你在第i行从左往右数第j个数上，下同），你可以选择移动到 (i+1,j) 或
(i+1,j+1)。

你想让你经过的所有位置（包括起点和终点）的数字总和最大。求这个最大值。

```c++
int T6(){
    int i, j, n;
    int a[100][100]; //用于存放三角形
    int b[100][100]; //用于复制a数组
    printf("请输入数字三角形的行数：\n");
    scanf("%d", &n); //获取输入的行数
    printf("请输入数字三角形：\n");
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= i; j++)
        {
            scanf("%d", &a[i - 1][j - 1]);     //输入三角形
            b[i - 1][j - 1] = a[i - 1][j - 1]; //复制
        }
    }
    for (int row = n - 2; row >= 0; row--)
    { //从倒数第二行开始往上递推
        for (int col = 0; col <= row; col++)
        {
            if (a[row + 1][col] > a[row + 1][col + 1])
            {                                   //将每个数下面的两个数进行比较
                a[row][col] += a[row + 1][col]; //取较大的数加
            }
            else
            {
                a[row][col] += a[row + 1][col + 1];
            }
        }
    }
    printf("路径总和最大为：\n");
    printf("%d\n", a[0][0]);
}
```

第七题老师删了

### 8 给定一个存放整数的数组，重新排列数组使得数组左边为偶数，右边为奇数。

如对数组：1,2,3,4,5,6,7,8,9处理后，该数组变为：2,4,6,8,1,3,5,7,9。

```c++
 /*
     解决思路：数组左边left，右边right。左边遇到第一个偶数停止，右边遇到第一个奇数停止。二者进行交换
     知道left>right操作结束
 */
void t8(int *arr, int length)
{
    int left = 0;
    int right = length - 1;
    int flag;
    while (left < right) 

    {
        if (arr[left] % 2 == 0)
        {
            left++;
            continue;
        }
        if (arr[right] % 2 != 0)
        {
            right--;
            continue;
        }
        if (left < right)
        {
            flag = arr[left];
            arr[left++] = arr[right];
            arr[right--] = flag;
        }
    }
}

```

### 9、编写函数double getRestul(int n)并测试，它的功能是：根据以下公式计算结果S。

![a](C:\Users\King\OneDrive\Documents\a\aa.png)

```c++
double getRestul(int n)
{
    if (n == 1)
    {
        return 1;
    }

    return getRestul(n - 1) + pow(-1, n - 1) * 1 / (2 * n - 1);
}

```
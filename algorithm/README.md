# [算法考试](exam)

# 算法实验

## 实验一：递归与分治

实验目的

理解递归算法的思想和递归程序的执行过程，并能熟练编写递归程序。

掌握分治算法的思想，对给定的问题能设计出分治算法予以解决。

实验预习内容

编程实现讲过的例题：整数划分，小车问题。
对本实验中的问题，设计出算法并编程实现。

试验内容和步骤

1.用递归找个整数数组的最大值

2.用递归实现冒泡排序

3． 整数因子分解问题

```txt
例如，当n=12时，共有8种不同的分解式
12=12*1
12=6*2
12=4*3
12=3*4   12=3*2*2
12= 2*6 12=2*3*2 12=2*2*3
输入n，求n的整数因子分解 小车问题
```

4.参见教材整数划分问题（打印出各种划分方案）

5. 小车问题
   【问题描述】
   甲、乙两人同时从 A地出发要尽快同时赶到 B地。出发时 A 地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：
   怎样利用小车才能使两人尽快同时到达。
   【输入】
   仅一行，三个数据分别表示 AB两地的距离 s，人的步行速度 a，车的速度 b。
   【输出】
   两人同时到达 B地需要的最短时间。
   【样例】

输入：120 5 25         输出： 9.6000000000E+00
解析：最佳方案为:甲先乘车到达K处后下车步行,小车再回头接已走到C处的乙,在D处相遇后,乙再乘车赶往B,最后甲,乙一起到达B地.这样问题就转换成了求K处的位置,我们用二分法,不断尝试,直到满足同时到达的时间精度.

## 实验二：动态规划

实验目的：理解动态规划的基本思想，理解动态规划算法的两个基本要素最优子结构性质和子问题的重叠性质。熟练掌握典型的动态规划问题。掌握动态规划思想分析问题的一般方法，对较简单的问题能正确分析，设计出动态规划算法，并能快速编程实现。

实验内容：编程实现讲过的例题：最长公共子序列问题、投资问题等。

1. 最长公共子序列
2. 投资问题
3. 01背包问题，背包限重50. 物品重量 分别为10，20，30
   价值分别为60,100,120，求装入背包物品价值最大为多少，具体怎么选择物品

## 实验三：动态规划

**实验目的：进一步深入理解动态规划的基本思想** **, ** **熟练掌握典型的动态规划问题。能快速编程实现。**

**实验内容：编程实现讲过的例题：拦截导弹、最大子段和问题、** 。

.

## 1. 最大子段和

给出一个序列，其子段为该序列的一个连续的区间。例如：(1 -1 2 2 3 -3 4
-4) ，(2 2 3 -3 4)为他的一个子段。给出一个序列，求出数字求和最大的一个子段。例如上面的序列， (2 2 3 -3 4)就是一个最大的子段，数字的总和为8

问题解析：对于最大字段和的决策：

设dp[x] 为：以x位置处的数字为结尾，能够得到的最大子段和。按顺序枚举每个位置：对于每个数字有两种决策：

自己和自己组成一个子段自己和前面的数字组成一个子段。至于前面如何组成一个最大的子段则不需要关心。

所以，dp[x] :=
max(data[x], dp[x-1] + data[x])

## 2.拦截导弹（Noip2002）

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统 有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高 于前一发的高度。 某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以 只有一套系统，因此有可能不能拦截所有的导弹。输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹。

![](/img/a.png)

状态的表示opt [i]，表示当第i个导弹必须选择时，前i个导弹最多能拦截多少。

每个导弹有一定的高度，当前状态就是以第i个导弹为最后一个打的导弹。以前状态就是在这个导弹以前打的那个导弹。

显然这是十分能够体现状态间的联系的题目。

状态转移方程：

opt[i]=max(opt[j])+1 (h[i]>=h[j],0=<j<i)

{h[i]存，第i个导弹的高度}

最大的opt[i]就是最终的解。

## 3

现有一笔经费可以报销一定额度的发票。允许报销的发票类型包括买图书（A类）、文具（B类）、差旅（C类），要求每张发票的总额不得超过1000元，每张发票上，单项物品的价值不得超过600元。现请你编写程序，在给出的一堆发票中找出可以报销的、不超过给定额度的最大报销额。

Input

测试输入包含若干测试用例。每个测试用例的第1行包含两个正数 Q 和 N，其中 Q 是给定的报销额度，N（<=30）是发票张数。随后是 N 行输入，每行的格式为：

m Type_1:price_1 Type_2:price_2 ... Type_m:price_m

其中正整数 m 是这张发票上所开物品的件数，Type_i 和 price_i 是第 i 项物品的种类和价值。物品种类用一个大写英文字母表示。当N为0时，全部输入结束，相应的结果不要输出。

Output

对每个测试用例输出1行，即可以报销的最大数额，精确到小数点后2位。

Sample Input

200.00 3

2 A:23.50 B:100.00

1 C:650.00

3 A:59.99 A:120.00 X:10.00

1200.00 2

2 B:600.00 A:400.00

1 C:200.50

1200.50 3

2 B:600.00 A:400.00

1 C:200.50

1 A:100.00

100.00 0

Sample Output

123.50

1000.00

1200.50

## 4.

有如下所示的数塔，要求从顶层走到底层，若每一步只能走到相邻的结点，则经过的结点的数字之和最大是多少？

Input

```
输入数据首先包括一个整数C,表示测试实例的个数，每个测试实例的第一行是一个整数N(1 <= N <= 100)，表示数塔的高度，接下来用N行数字表示数塔，其中第i行有个i个整数，且所有的整数均在区间[0,99]内。
```

Output

```
对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行。
```

## 实验4 ：回溯算法

实验目的：熟练掌握回溯算法，理解回溯法的算法思想，掌握回溯法的基本步骤
实验内容：回溯算法的两种解空间结构

1.用回溯法解决子集树问题

题目：求集合(a,b,c,d)的子集， 如：a,b,c,d,ab,cd,bc...............

2.用回溯法解决排列数问题

题目：求集合(1,2,3,4,5,6)的 全排列 并打印全部

3、走台阶问题
【题目叙述】你眼前一共有n级台阶（n为正整数），现在你要走完这n级台阶，已知你只能一步走一级或一步走两级，请你算算一共有多少种走法，并把这些走法都给出。?
【输入输出样例】输入：3
输出：1 1 1
1 2
2 1

4、用回溯法解决01背包问题，需要通过限界剪枝和可行性约束剪枝

## 实验五：分支限界算法

实验目的：熟练掌握分支限界
实验内容：分支限界法的几种形式

1.用分支限界法解决子集树问题

题目：求集合(a,b,c,d)的子集， 如：a,b,c,d,ab,cd,bc...............

2.用分支限界法解决排列数问题

题目：求集合(1,2,3,4,5,6)的 全排列 并打印全部

3、01背包问题
背包重量限制50，物品重量分别为10，30，20， 价值分别为60，120，100

4、二维数组maze[M][N]它表示一个M×N的迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。
int maze[10][10]=
{
{1,1,1,1,1,1,1,1,1,1},
{1,0,0,1,0,0,0,1,0,1},
{1,0,0,1,0,0,0,1,0,1},
{1,0,0,0,0,1,1,0,0,1},
{1,0,1,1,1,0,0,0,0,1},
{1,0,0,0,1,0,0,0,0,1},
{1,0,1,0,0,0,1,0,0,1},
{1,0,1,1,1,0,1,1,0,1},
{1,1,0,0,0,0,0,0,0,1},
{1,1,1,1,1,1,1,1,1,1}
};

## 实验六： 算法综合

实验目的：考察学生对课程五大常用算法的掌握程度
实验内容：递归分治法，动态规划法，回溯法等

1、超级楼梯问题：有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级或三级，要走上第M级，共有多少种走法？要求时间复杂度为O(n)，空间复杂度为O(1)。
f(1)=1
f(2)=2
f(3)=3
1 1 1
1 2
2 1

f(4)= f(1)+f(2)+f(3)

int get(int M)
{
int F[5] ={0,1,2,3,0};

if(m > 0 && m < 4)
return F[m];

for(int i = 4; i <= M; i++)
{
F[4] = F[1] + F[2] +F[3];
F[3] = F[4];
F[2] = F[3];
F[1] = F[2];
}

return F[4];
}

f(n)= f(n-1) + f(n-2) + f(n-3)

2、请用递归算法判断一个整数数组是否是对称的，比如数组为{1,2,3,2,1}就是对称的。要求递归函数返回bool类型。

bool isDuiCheng(int a[] , int left,int righ)
{
if(left >= right)
return true;

return a[left] == a[right] && isDuiCheng(a,left + 1, right - 1);

}

3、最大子段和问题：给出一个序列，其子段为该序列的一个连续的区间。例如：(1 -1 2 2 3 -3 4 -4) ，(2 2 3 -3 4)为他的一个子段。给出一个序列，求出数字求和最大的一个子段。例如上面的序列， (2 2 3 -3 4)就是一个最大的子段，数字的总和为8。

flag[i]:
dp[i]:表示以第i个数字开头得到的最大子段和
dp[0] = max{a[0],a[0]+dp[1]}
dp[1] = max{a[1],a[1]+dp[2]}
dp[2] = max{a[2],a[2]+dp[3]}   /// 2 2 3 -3 4    8
dp[7] = a[7]

4、请用回溯法实现：将正整数n表示成一系列正整数之和，即n=n1+n2+…+nk，其中n1≥n2≥…≥nk≥1，k≥1。正整数n的这种表示称为正整数n的划分。输出正整数n的不同划分个数及具体的划分形式。
例如正整数6有如下11种不同的划分：
6；
5+1；
4+2，
4+1+1；
3+3，
3+2+1，
3+1+1+1；
2+2+2，
2+2+1+1，
2+1+1+1+1；
1+1+1+1+1+1

int x[10];
void bt(int t)
{
if(getsum(t) == n)
{
printOneSolution(t);
return ;
}

for(int i = (t=0? n :x[t-1]); i >= 1; i--)
{
x[t] = i;
bt(t+1)
}

}

int main()
{
bt(0);
return 1;
}

5.请用分支限界法实现：
八皇后问题：在8×8的国际象棋盘上，放置八个皇后，使任何一个皇后都不能吃掉另一个
国际象棋规则中，皇后可以吃到任何一个与他在同一行、同一列或者同一斜线上的敌方棋子，所以八皇后问题的所有解满足：
8个皇后都不在同一行、同一列，或者同一斜线上；或者任意行、列或者斜线上 有且仅有一个皇后。